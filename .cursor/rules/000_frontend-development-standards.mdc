---
description: 前端项目通用开发规范
globs: 
alwaysApply: true
---

# 前端项目通用开发规范

## 沟通响应规范

### 语言使用
- **始终使用简体中文**：与用户进行沟通交流，确保信息传达清晰准确
- **技术术语保持英文原文**：避免翻译造成的歧义（如：API、DOM、Promise、React Hook 等）
- **术语解释策略**：解释技术概念时，优先使用业界通用术语，必要时辅以中文解释；对于复杂概念，可先给出中文解释，再提供英文术语对照
- **代码语言规范**：
  - 代码中的变量、函数、类名等标识符使用英文命名
  - 代码注释可使用中文，便于理解（遵循项目的注释规范）
  - 代码示例中的字符串字面量根据实际业务场景选择语言
- **错误信息规范**：错误提示信息使用中文，便于用户理解；技术错误代码和标识符保持英文原文

### 响应原则
- **上下文理解**：充分理解用户需求，结合项目上下文、相关文件、配置文件等进行分析和回答
- **专业准确**：提供专业、准确的技术建议和解决方案，确保建议具有实用性和可操作性
- **理由说明**：在给出建议时，明确说明理由和适用场景，帮助用户理解技术选型和实现思路
- **主动调研**：遇到不确定的问题时，主动查阅代码库、配置文件或相关文档，确保回答的准确性
- **优先级处理**：先回答核心问题，再补充细节和扩展说明，确保关键信息优先传达
- **完整性保障**：提供完整、可执行的解决方案，包括必要的代码示例、配置说明和注意事项，避免碎片化回答
- **方案对比**：当存在多种实现方案时，对比分析各方案的优缺点，并推荐最适合当前场景的方案
- **不确定处理**：对于无法确定或超出能力范围的问题，明确说明不确定的原因，提供可能的解决方向或建议查阅的文档
- **规则文件执行**：每次回答必须强制严格根据规则文件执行，所有操作和建议必须符合规则文件的要求
- **规则文件校验**：每次回答后，必须根据规则文件进行校验，检查回答内容是否符合规则文件要求；如果不符合，必须重新执行并修正，直到完全符合规则文件要求
- **自我检查**：回答完成后，立即对回答内容进行检查、纠错和修复，确保信息准确无误
- **文档同步检查**：每次回答后，必须检查是否存在相关的文档，如果存在，必须同步更新文档内容（参考"文档同步机制"章节）
- **MDC 文件生成规范**：基于现有 MDC 规则文件和项目上下文生成新的 MDC 文件时，必须避免生成重复内容
  - **用途说明**：MDC 文件主要用于与 AI 大模型沟通使用，这是 MDC 文件的核心用途，需要重点关注与注意
  - **重复内容检查**：生成前必须检查现有 MDC 文件（如 000、001 等）中是否已包含相同或类似的内容
  - **内容策略**：
    - **禁止完全重复**：新文件不应包含与现有文件完全相同的内容
    - **允许补充**：可以补充现有文件未涵盖的内容
    - **允许覆盖**：可以覆盖或细化现有文件中的内容，但需明确说明覆盖原因
  - **引用策略**：对于已在现有文件中定义的内容，应使用引用（如"参考 000 规范"、"参考 001 规范"）而非重复描述
  - **示例**：如果已有 000（通用前端规范）和 001（Monorepo 通用规范），生成 002（项目特定规范）时，不应重复 000 和 001 中的通用内容，而应专注于项目特定的规则和补充说明
- **Git 提交信息**：每次回复后，如果存在暂存的更改，必须针对所有暂存更改的文件给出一个综合的、符合 Conventional Commits 规范的 git 提交信息（参考"版本控制规范"章节）
- **变更影响分析**：修改代码前，分析变更的影响范围，包括依赖的文件、相关的测试、文档等
- **错误预防**：在提供解决方案时，主动识别可能的错误场景，并提供预防措施
- **可回滚性**：对于重要变更，提供回滚方案或说明如何撤销变更

## 开发工具配置

### Node.js 版本管理
- **必须使用 Volta 管理 Node.js 版本**，确保开发环境一致性
- **全局安装要求**：Volta 必须全局安装，在使用前应检查是否已安装
- **检查方式**：执行 `volta --version` 检查是否已安装
- **安装方式**：若未安装，通过官方安装脚本或包管理器进行全局安装
  - Windows: `winget install Volta.Volta` 或使用官方安装脚本
  - macOS/Linux: `curl https://get.volta.sh | bash` 或使用包管理器
- **安装后验证**：安装完成后通过 `volta --version` 确认安装成功
- **版本锁定**：若项目 `package.json` 中未指定 Node.js 版本，执行 `volta pin node@latest` 锁定最新 LTS 版本
- **配置检查**：优先检查项目中是否已存在 Volta 配置，遵循现有配置

### 包管理器选择
- **优先使用 @antfu/ni 智能命令**：
  - **全局安装要求**：`@antfu/ni` 必须全局安装，在使用前应检查是否已安装
    - **检查方式**：执行 `ni --version` 或 `which ni` 检查是否已安装
    - **安装方式**：若未安装，执行 `npm install -g @antfu/ni` 进行全局安装
    - **安装后验证**：安装完成后通过 `ni --version` 确认安装成功
  - **使用方式**：
    - 使用 `ni` 安装依赖（自动识别项目锁文件）
    - 使用 `nr` 运行 package.json 中的脚本命令
    - 自动识别项目锁文件类型（bun.lockb、pnpm-lock.yaml、package-lock.json、yarn.lock）
- **降级方案**：若 ni 不可用，使用 **npm** 作为备选包管理器
- **锁文件检查**：执行包管理命令前，优先检查项目根目录的锁文件类型，使用对应的包管理器

## 项目架构规范

### 目录结构设计原则
- **分层架构**：按业务领域或功能模块划分目录，严格遵循关注点分离原则
- **命名一致性**：采用描述性命名，目录和文件名需清晰反映其用途和职责
- **模块化设计**：
  - 相关功能聚合到同一模块，保持高内聚
  - 最小化跨模块依赖，降低耦合度
  - 每个模块职责明确，边界清晰
- **模块入口规范**：
  - 每个模块必须包含 `index.ts`（或 `index.tsx`）作为聚合导出入口
  - 避免在模块外部直接导入模块内部文件
  - 通过 `index.ts` 统一管理模块的对外接口
- **层级控制**：
  - 目录嵌套深度不超过 5-6 层，保持结构清晰可维护
  - 避免过深的嵌套导致路径冗长和导航困难
- **资源分类**：
  - 严格区分源代码（`src/`）、静态资源（`public/` 或 `assets/`）、配置文件（`configs/`）和测试文件（`tests/` 或 `__tests__/`）
- **依赖管理**：参考"依赖管理规范"章节
- **环境变量管理**：
  - 使用 `.env` 文件管理环境变量（`.env.local`、`.env.development`、`.env.production` 等）
  - 敏感信息处理参考"安全规范"章节
  - 在 `.gitignore` 中忽略 `.env.local` 等包含敏感信息的文件
  - 提供 `.env.example` 文件作为环境变量模板
- **约定优先原则**：
  - 优先遵循项目现有的结构和命名约定
  - 其次采用框架官方推荐的项目结构
  - 最后参考行业最佳实践

## 代码开发准则

### 代码质量标准
- **可测试性**：
  - 组件保持单一职责原则（SRP）
  - 业务逻辑与视图层分离，便于单元测试
  - 函数保持纯函数特性，避免副作用
- **DRY 原则**（Don't Repeat Yourself）：
  - 提取公共逻辑为独立的工具函数或工具类
  - 消除代码重复，提升可维护性
  - 公共逻辑放置在 `utils/` 或 `helpers/` 目录
- **简洁性**：
  - 遵循 KISS 原则（Keep It Simple, Stupid）
  - 避免过度设计和过早优化
  - 优先选择简单、直接的实现方案
- **语义化命名**：
  - 变量、函数、类名需准确描述其用途和含义
  - 使用有意义的命名，避免缩写和单字母变量（循环计数器除外）
  - 布尔值使用 `is`、`has`、`should` 等前缀

### TypeScript 类型规范
- **类型定义原则**：
  - **优先使用类型推断**：充分利用 TypeScript 的类型推断能力，避免不必要的类型注解，保持代码简洁
- **命名规范**：
  - 变量、函数使用 `camelCase`
  - 类、接口、类型别名、枚举使用 `PascalCase`
  - 常量使用 `UPPER_CASE`
  - 私有成员可使用 `_` 前缀（如 `_privateMethod`）
- **接口与类型选择**：
  - 优先使用 `interface` 定义对象类型，便于扩展
  - 使用 `type` 定义联合类型、交叉类型或复杂类型
  - 避免定义空接口，除非用于扩展或标记
- **类型安全**：
  - 启用严格模式（`strict: true`）
  - 充分利用类型系统的优势，减少运行时错误
  - 为第三方库缺失的类型定义添加类型声明文件

### 代码风格一致性
- 严格遵循项目配置的代码规范（ESLint、Prettier 等）
- 遵循项目特定的代码风格规则
- 保持整个项目的代码风格统一

### 代码实现优先级
- **最优方案选择**：优先选用极简、优雅、性能三者兼具的实现方案
- **实现优先级排序**：
  1. **极简性**：代码简洁、易读、易理解
  2. **代码优雅**：结构清晰、逻辑合理、符合设计模式
  3. **性能优化**：在保证前两者的基础上，考虑性能优化
- **避免过度优化**：不要为了微小的性能提升而牺牲代码可读性

### 注释编写规范

#### JSDoc 标准
所有变量、函数、类、接口的类型定义必须使用 **JSDoc 格式**进行注释

#### 注释类型与格式

**1. 简单注释**（仅有标题时）
```typescript
/** 用户服务类 */
```

**2. 详细注释**（需要描述说明时）
```typescript
/**
 * 用户服务类
 *
 * 负责用户相关的业务逻辑处理，包括注册、登录、信息管理等核心功能
 */
```

**3. 参数注释**（有参数或返回值时）
```typescript
/**
 * 获取用户信息
 * @param {string} userId - 用户唯一标识符
 * @returns {User} 用户对象，包含用户基本信息
 */
```

**4. 完整注释**（既有描述又有参数时）
```typescript
/**
 * 用户登录验证
 *
 * 通过用户名和密码进行用户身份验证，验证成功返回用户令牌。
 * 支持多种认证方式，包括普通登录和第三方登录。
 *
 * @param {string} username - 用户名或邮箱
 * @param {string} password - 用户密码（已加密）
 * @returns {Promise<string>} JWT 令牌字符串
 * @throws {AuthError} 当用户名或密码错误时抛出认证异常
 */
```

**5. 行内注释**（函数内部逻辑说明）
```typescript
// 验证用户权限，确保只有管理员可以访问
if (!hasPermission) {
  throw new Error('权限不足');
}
```

**6. 类型定义注释**（Interface 和 Type 定义）
```typescript
/**
 * API 统一响应接口
 * @template T 响应数据的类型
 */
interface APIResponse<T> {
  /** 响应状态码 */
  code: number;
  /** 响应数据 */
  data: T;
  /** 响应消息 */
  message: string;
}
```

#### 注释编写原则
- **必要性**：代码本身能表达清楚的逻辑，无需添加注释
- **准确性**：注释内容必须与代码实现保持一致
- **及时性**：修改代码时同步更新相关注释
- **简洁性**：注释简洁明了，避免冗余和废话

## 工程化实践

### 技术选型原则
- **成熟稳定优先**：优先选用经过验证、社区活跃的成熟解决方案
- **评估标准**：考虑维护状态、社区支持、文档完整性、性能表现等因素

### 架构设计原则
- **可维护性**：代码结构清晰，便于理解和修改
- **可扩展性**：预留扩展点，支持未来功能迭代
- **性能优化**：在保证代码质量的前提下，考虑性能优化

### 版本控制规范
- **提交信息规范**：
- **格式要求**：遵循约定式提交（Conventional Commits）格式：`<type>(<scope>): <subject>`
- **分支管理**：
  - 遵循项目的分支策略（如 Git Flow、GitHub Flow）
  - 保持主分支（main/master）代码始终可运行
  - 功能开发使用特性分支，合并前需进行代码审查

### 错误处理规范
- **全面性**：全面处理边界情况和异常状态
- **信息性**：提供有意义的错误信息，便于调试和问题定位
- **用户友好**：向用户展示友好的错误提示，避免暴露技术细节

### 代码修改和重构规范
- **修改前检查清单**：
  - 检查是否有其他代码依赖此部分
  - 检查是否有相关测试需要更新
  - 检查是否有相关文档需要同步（参考"文档同步机制"章节）
- **修改时注意**：
  - 保持向后兼容性，避免破坏性变更
  - 如果必须进行破坏性变更，明确标注并更新版本号
  - 修改后运行测试确保功能正常
- **重构原则**：
  - 小步重构，每次只改一个方面
  - 重构前确保有测试覆盖
  - 重构后运行完整测试套件
  - 重构时保持功能不变，只改进代码结构
- **删除代码时**：
  - 检查是否有其他地方引用
  - 检查是否有相关测试需要删除或更新
  - 检查是否有相关文档需要更新（参考"文档同步机制"章节）
  - 如果是公共 API，考虑废弃（deprecate）而不是直接删除

### 文件操作规范
- **创建新文件时**：
  - 遵循项目的目录结构和命名规范
  - 添加必要的文件头注释（如 `@file` 注释）
  - 检查是否需要更新 `index.ts` 等入口文件
  - 检查是否需要添加相关文档（参考"文档同步机制"章节）
- **删除文件时**：
  - 检查是否有其他文件导入此文件
  - 检查是否需要更新导出文件（如 `index.ts`）
  - 检查是否需要删除相关测试文件
  - 检查是否需要更新相关文档（参考"文档同步机制"章节）
- **重命名文件时**：
  - 更新所有导入此文件的地方
  - 更新导出文件（如 `index.ts`）
  - 更新相关文档中的引用（参考"文档同步机制"章节）
  - 使用 IDE 的重构功能确保所有引用都被更新

### 依赖管理规范
- **基本原则**：
  - 统一在 `package.json` 中声明所有依赖，避免分散配置
  - 不使用全局依赖，确保项目依赖可复现
  - 严格区分 `dependencies` 和 `devDependencies`
    - 运行时必需的依赖放入 `dependencies`
    - 仅在开发、构建、测试时需要的依赖放入 `devDependencies`
- **版本锁定策略**：
  - 生产依赖使用精确版本或版本范围锁定
  - 开发依赖可使用 `^` 或 `~` 允许小版本更新
  - 定期更新依赖，关注安全漏洞修复（参考"安全规范"章节）
- **添加新依赖时**：
  - 评估依赖的必要性和安全性
  - 检查依赖的维护状态和社区活跃度
  - 确认依赖的许可证与项目兼容
  - 添加到正确的分类（`dependencies` 或 `devDependencies`）
  - 记录添加依赖的原因（在提交信息中）
- **更新依赖时**：
  - 查看更新日志，了解变更内容
  - 检查是否有破坏性变更
  - 运行测试确保兼容性
  - 如果 API 有变化，更新相关文档（参考"文档同步机制"章节）
- **处理依赖冲突时**：
  - 优先使用项目已使用的版本
  - 如果必须升级，评估影响范围
  - 使用 `pnpm why` 或类似命令分析依赖树
  - 考虑使用 `peerDependencies` 或 `overrides` 解决冲突

### 调试和问题诊断规范
- **错误处理原则**：
  - 仔细阅读错误信息，理解错误原因
  - 使用适当的调试工具（浏览器开发者工具、Node.js 调试工具等）
  - 添加适当的日志输出帮助定位问题
  - 检查边界情况和异常输入
- **编译错误**：
  - 检查类型定义是否正确
  - 检查导入路径是否正确
  - 检查配置文件是否正确
- **类型错误**：
  - 理解类型错误的根本原因
  - 检查类型定义是否完整
  - 考虑是否需要添加类型断言或类型守卫
  - 避免使用 `any`，优先使用正确的类型
- **运行时错误**：
  - 使用浏览器开发者工具查看错误信息
  - 检查控制台是否有警告或错误
  - 使用断点调试定位问题
  - 检查数据格式是否符合预期
  - 使用 try-catch 捕获和处理异常
- **性能问题诊断**：
  - 使用性能分析工具（如 Chrome DevTools Performance）
  - 识别性能瓶颈（渲染、网络、计算等）
  - 优先优化影响最大的部分
  - 避免过早优化，先确保功能正确

### 代码审查规范
- **审查要点**：
  - 代码是否符合项目规范
  - 是否有潜在的安全问题
  - 是否有性能问题
  - 是否有测试覆盖
  - 文档是否同步更新（参考"文档同步机制"章节）
- **反馈处理**：
  - 认真对待审查反馈
  - 及时修复审查中发现的问题
  - 如果不理解反馈，主动沟通澄清
  - 修复后重新提交审查

### 工具使用规范
- **命令执行前**：
  - 确认当前工作目录是否正确
  - 确认命令参数是否正确
  - 确认是否有必要的权限
- **脚本执行规范**：
  - **环境检测**：执行脚本前，必须先检测当前运行环境（如 PowerShell、Bash、CMD 等），根据环境生成对应的命令
  - **命令生成**：根据检测到的环境类型，生成符合该环境语法的命令（如 PowerShell 使用 `$env:` 语法，Bash 使用 `export` 语法）
  - **优先使用智能命令**：运行 package.json 中的脚本命令时，优先使用 `@antfu/ni` 提供的 `nr` 命令（参考"包管理器选择"章节）
    - 使用 `nr <script-name>` 替代 `npm run <script-name>`、`pnpm run <script-name>` 等
    - `nr` 会自动识别项目锁文件类型，使用对应的包管理器执行脚本
  - **降级方案**：若 `nr` 不可用，根据项目锁文件类型使用对应的包管理器命令（如 `pnpm run`、`npm run` 等）
- **配置修改时**：
  - 理解配置的作用和影响范围
  - 修改后测试确保配置生效
  - 记录配置变更的原因
  - 更新相关文档（参考"文档同步机制"章节）

### 安全规范
- **敏感信息处理**：
  - 不在代码中硬编码敏感信息（API 密钥、密码等）
  - 使用环境变量管理敏感信息
  - 确保 `.gitignore` 正确配置，避免提交敏感文件
  - 定期检查代码中是否有泄露的敏感信息
- **依赖安全**：
  - 定期检查依赖的安全漏洞
  - 使用 `pnpm audit` 或类似工具检查
  - 及时更新有安全漏洞的依赖
  - 关注依赖的维护状态

### 兼容性规范
- **浏览器兼容性**：
  - 明确项目支持的浏览器版本
  - 使用 Babel 或类似工具处理兼容性
  - 测试主要浏览器的兼容性
- **版本兼容性**：
  - 明确项目的 Node.js 版本要求
  - 明确项目的包管理器版本要求
  - 在文档中明确说明版本要求

### 代码生成规范
- **生成代码时**：
  - 遵循项目的代码风格和命名规范
  - 添加必要的类型定义和注释
  - 检查生成的代码是否符合项目架构
  - 确保生成的代码可以直接使用，无需手动修改
- **生成组件时**：
  - 遵循组件的命名规范（如 Vue 组件使用 PascalCase）
  - 添加必要的 Props、Emits、Slots 类型定义
  - 添加组件说明注释
  - 检查是否需要添加样式文件
- **生成工具函数时**：
  - 添加 JSDoc 注释说明函数用途
  - 添加类型定义和参数说明
  - 考虑边界情况和错误处理
  - 检查是否需要添加单元测试

### 测试编写规范
- **测试文件组织**：
  - 测试文件与源文件同目录或 `__tests__` 目录
  - 测试文件命名：`*.test.ts`、`*.spec.ts` 或 `*.test.tsx`
  - 测试文件应清晰反映测试的内容
- **测试编写原则**：
  - 每个测试用例只测试一个功能点
  - 测试用例名称清晰描述测试内容
  - 使用描述性的测试描述（describe/it 语句）
  - 测试应该独立，不依赖其他测试的执行顺序
- **测试覆盖**：
  - 核心功能必须有测试覆盖
  - 公共 API 必须有测试覆盖
  - 边界情况和错误处理应该有测试覆盖
  - 优先保证质量，再追求覆盖率

### 常见问题快速参考
- **构建失败**：
  - 检查 Node.js 版本是否符合要求
  - 检查依赖是否正确安装（删除 `node_modules` 重新安装）
  - 检查配置文件是否正确（参考"调试和问题诊断规范"中的"编译错误"部分）
  - 查看构建日志中的具体错误信息
- **类型错误**：参考"调试和问题诊断规范"中的"类型错误"部分
- **导入错误**：参考"调试和问题诊断规范"中的"编译错误"部分（重点检查导入路径、文件存在性、文件扩展名和路径别名配置）
- **运行时错误**：参考"调试和问题诊断规范"中的"运行时错误"部分

## 文档编写标准

### 通用要求
- **格式统一**：统一使用 Markdown 格式编写文档
- **语言规范**：
  - 语言简洁明了，逻辑清晰
  - 主要使用中文编写，技术术语保留英文原文
- **质量检查**：严格检查拼写和语法错误，确保文档质量

### 文档同步机制
**核心原则**：文档内容必须与代码实现保持同步，这是所有开发活动的必要环节。
- **同步时机**：
  - 修改代码后，必须同步更新相关文档
  - 添加新功能时，必须更新功能文档和 API 文档
  - 修改配置时，必须更新配置说明文档
  - 修复 Bug 时，如果涉及行为变更，必须更新相关文档
- **同步检查流程**：
  1. **识别相关文档**：确定修改内容涉及哪些文档（README.md、API 文档、开发文档、配置文档等）
  2. **检查文档存在性**：使用工具搜索项目中是否存在相关文档
  3. **对比内容一致性**：将代码实现与文档内容进行对比，找出不一致之处
  4. **更新文档内容**：根据代码实现更新文档，确保文档准确反映当前实现
  5. **验证更新完整性**：检查文档更新是否完整，是否遗漏重要信息
- **文档类型识别**：
  - **README.md**：项目概览、快速开始、开发指南
  - **API 文档**：函数、类、接口的类型定义和使用说明
  - **开发文档**：开发流程、配置说明、架构设计
  - **使用指南**：组件使用示例、最佳实践
  - **变更日志**：版本更新、功能变更、Bug 修复
- **同步优先级**：
  1. **高优先级**：API 文档、README.md 中的快速开始和配置说明
  2. **中优先级**：开发文档、使用指南
  3. **低优先级**：变更日志、历史文档

### 文档目录结构
```
项目根目录/
├── README.md           # 项目概览和快速开始指南
├── docs/               # 详细文档目录
│   ├── development/    # 开发文档（按功能模块划分）
│   └── guide/          # 使用指南（按功能模块划分）
```

### README.md 必备内容
- **项目介绍**：项目名称、核心功能、应用场景
- **技术栈说明**：主要技术栈和关键依赖版本
- **目录结构说明**：项目目录结构树状图及说明
- **快速开始**：
  - 环境要求（Node.js 版本等）
  - 安装步骤
  - 开发环境启动
  - 构建和部署
- **开发指南**：开发规范、贡献指南等

### 文档组织规范
- **结构原则**：采用"总-分"结构，从概述到细节，层层递进
- **信息优先级**：关键信息前置，突出重点内容
- **内容组织**：相关内容集中组织，避免信息碎片化
- **格式规范**：
  - 合理使用标题层级（H1-H6），保持层级清晰
  - 使用列表、代码块、表格等元素提升可读性
  - 段落保持简洁，避免大段文字堆砌

### 代码示例标准
- **完整性**：提供完整可执行的代码片段，确保可以直接运行
- **简洁性**：示例代码简洁易懂，突出核心逻辑，避免不必要的复杂性
- **注释说明**：关键部分添加 JSDoc 注释，说明实现思路和注意事项
- **预期说明**：明确说明代码的预期输出和行为效果
- **版本同步**：确保示例代码与当前 API 版本保持同步，及时更新过时示例（参考"文档同步机制"章节）

### 文档维护规范
- **定期审查**：定期审查文档内容，确保与代码实现保持一致（参考"文档同步机制"章节）
- **变更追踪**：代码变更时，记录需要同步的文档清单（参考"文档同步机制"章节）
- **版本对应**：文档版本应与代码版本对应，重大变更应在文档中明确标注
- **反馈机制**：建立文档反馈机制，及时修复文档中的错误和遗漏
- **自动化检查**：在 CI/CD 流程中集成文档检查，确保文档与代码同步（参考"文档同步机制"章节）
